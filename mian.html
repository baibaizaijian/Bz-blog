<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.20" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const useChoice = localStorage.getItem('vuepress-color-scheme')
      const systemStatus =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (useChoice === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (useChoice === 'dark' || systemStatus) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>css | BZZ的记录博客</title><meta name="description" content="这是我的第一个博客站点">
    <link rel="preload" href="/assets/style-vQlSTmni.css" as="style"><link rel="stylesheet" href="/assets/style-vQlSTmni.css">
    <link rel="modulepreload" href="/assets/app-BSV0vqsL.js"><link rel="modulepreload" href="/assets/mian.html-DiTanyI_.js">
    <link rel="prefetch" href="/assets/index.html-bp_HeLHV.js" as="script"><link rel="prefetch" href="/assets/get-started.html-DPrzEWFS.js" as="script"><link rel="prefetch" href="/assets/archive1.html-B6rXRYl9.js" as="script"><link rel="prefetch" href="/assets/archive2.html-BiP_ZRbX.js" as="script"><link rel="prefetch" href="/assets/article1.html-DIwtZy9q.js" as="script"><link rel="prefetch" href="/assets/article10.html-rklilkCz.js" as="script"><link rel="prefetch" href="/assets/article11.html-D4bRBTul.js" as="script"><link rel="prefetch" href="/assets/article12.html-C87uzVe5.js" as="script"><link rel="prefetch" href="/assets/article2.html-ByJIhypY.js" as="script"><link rel="prefetch" href="/assets/article3.html-H32d0qic.js" as="script"><link rel="prefetch" href="/assets/article4.html-BoEFyusA.js" as="script"><link rel="prefetch" href="/assets/article5.html-D8jOjjdG.js" as="script"><link rel="prefetch" href="/assets/article6.html-DmqE0TYU.js" as="script"><link rel="prefetch" href="/assets/article7.html-87eBk6L-.js" as="script"><link rel="prefetch" href="/assets/article8.html-Bek3O8K_.js" as="script"><link rel="prefetch" href="/assets/article9.html-BQqZAK5R.js" as="script"><link rel="prefetch" href="/assets/sticky.html-CDlLUxns.js" as="script"><link rel="prefetch" href="/assets/sticky2.html-DNSz3vku.js" as="script"><link rel="prefetch" href="/assets/404.html-BgBiuTfO.js" as="script"><link rel="prefetch" href="/assets/index.html-BLxxJbnl.js" as="script"><link rel="prefetch" href="/assets/index.html-ChZcwnNR.js" as="script"><link rel="prefetch" href="/assets/index.html-BqopWtVm.js" as="script"><link rel="prefetch" href="/assets/index.html-DNqG2w5k.js" as="script"><link rel="prefetch" href="/assets/index.html-BuUr5cji.js" as="script"><link rel="prefetch" href="/assets/index.html-CmwHUKJ1.js" as="script"><link rel="prefetch" href="/assets/index.html-CsS1eHpm.js" as="script"><link rel="prefetch" href="/assets/index.html-Cn-7vIn3.js" as="script"><link rel="prefetch" href="/assets/index.html-B_TJdMsw.js" as="script"><link rel="prefetch" href="/assets/index.html-3X6C8U04.js" as="script"><link rel="prefetch" href="/assets/index.html-DpwMUdZ-.js" as="script"><link rel="prefetch" href="/assets/index.html-DVhSnA9-.js" as="script"><link rel="prefetch" href="/assets/index.html-mdOgIqRf.js" as="script"><link rel="prefetch" href="/assets/index.html-BMcBWhW0.js" as="script"><link rel="prefetch" href="/assets/index.html-DJ-tExL-.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/"><img class="vp-site-logo" src="https://vuejs.press/images/hero.png" alt="BZZ的记录博客"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">BZZ的记录博客</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="Home"><!--[--><!--[--><!--]--><!--]-->Home<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link route-link-active auto-link" href="/mian.html" aria-label="js"><!--[--><!--[--><!--]--><!--]-->js<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/" aria-label="Home"><!--[--><!--[--><!--]--><!--]-->Home<!--[--><!--[--><!--]--><!--]--></a></div><div class="vp-navbar-item"><a class="route-link route-link-active auto-link" href="/mian.html" aria-label="js"><!--[--><!--[--><!--]--><!--]-->js<!--[--><!--[--><!--]--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">css <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div vp-content><!--[--><!--]--><div><h1 id="css" tabindex="-1"><a class="header-anchor" href="#css"><span>css</span></a></h1><h3 id="_1-选择器的优先级规则" tabindex="-1"><a class="header-anchor" href="#_1-选择器的优先级规则"><span>1.选择器的优先级规则</span></a></h3><p>内联样式 &gt; ID 选择器 &gt; 类、伪类和属性选择器 &gt; 元素和伪元素选择器</p><h3 id="_2-说说em-px-rem-vh-vw区别" tabindex="-1"><a class="header-anchor" href="#_2-说说em-px-rem-vh-vw区别"><span>2.说说em/px/rem/vh/vw区别</span></a></h3><p>px表示像素</p><p>em是相对长度单位。相对于当前对象内文本的字体尺寸。</p><p>rem，相对单位，相对的只是HTML根元素<code>font-size</code>的值</p><p>vh、vw</p><p>vw ，就是根据窗口的宽度，分成100等份，100vw就表示满宽，50vw就表示一半宽。（vw 始终是针对窗口的宽），同理，<code>vh</code>则为窗口的高度</p><h1 id="js" tabindex="-1"><a class="header-anchor" href="#js"><span>js</span></a></h1><h3 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h3><table><thead><tr><th>分类</th><th>类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><strong>原始类型（值类型）</strong></td><td><code>number</code></td><td>数字（整数 &amp; 小数）</td><td><code>42, 3.14, NaN, Infinity</code></td></tr><tr><td></td><td><code>string</code></td><td>字符串</td><td><code>&quot;hello&quot;, &#39;world&#39;</code></td></tr><tr><td></td><td><code>boolean</code></td><td>布尔值</td><td><code>true, false</code></td></tr><tr><td></td><td><code>null</code></td><td>空值，表示<strong>对象为空</strong></td><td><code>let a = null;</code></td></tr><tr><td></td><td><code>undefined</code></td><td>变量未赋值</td><td><code>let b;</code></td></tr><tr><td></td><td><code>symbol</code></td><td>唯一值</td><td><code>Symbol(&quot;id&quot;)</code></td></tr><tr><td></td><td><code>bigint</code></td><td>大整数（ES11）</td><td><code>123n, 9007199254740991n</code></td></tr><tr><td><strong>引用类型（对象类型）</strong></td><td><code>Object</code></td><td>普通对象</td><td><code>{ key: &quot;value&quot; }</code></td></tr><tr><td></td><td><code>Array</code></td><td>数组</td><td><code>[1, 2, 3]</code></td></tr><tr><td></td><td><code>Function</code></td><td>函数</td><td><code>function() {}</code></td></tr><tr><td></td><td><code>Date</code></td><td>日期对象</td><td><code>new Date()</code></td></tr><tr><td></td><td><code>RegExp</code></td><td>正则表达式</td><td><code>/abc/i</code></td></tr><tr><td></td><td><code>Error</code></td><td>错误对象</td><td><code>new Error(&quot;Something went wrong&quot;)</code></td></tr></tbody></table><h3 id="数据类型的检查方法" tabindex="-1"><a class="header-anchor" href="#数据类型的检查方法"><span>数据类型的检查方法</span></a></h3><table><thead><tr><th>方法</th><th>适用场景</th><th>备注</th></tr></thead><tbody><tr><td><code>typeof</code></td><td>适用于基本类型</td><td><code>null</code> 误判为 <code>&quot;object&quot;</code></td></tr><tr><td><code>instanceof</code></td><td>适用于对象类型（数组、日期等）</td><td>不能判断基本类型</td></tr><tr><td><code>Object.prototype.toString.call(value)</code></td><td><strong>最准确</strong></td><td><strong>推荐</strong></td></tr><tr><td><code>Array.isArray(value)</code></td><td>判断数组</td><td><strong>比 <code>instanceof Array</code> 更安全</strong></td></tr><tr><td><code>Number.isNaN(value)</code></td><td>判断 NaN</td><td><strong>比 <code>isNaN()</code> 更精准</strong></td></tr></tbody></table><h3 id="数组的常用方法有哪些" tabindex="-1"><a class="header-anchor" href="#数组的常用方法有哪些"><span>数组的常用方法有哪些</span></a></h3><table><thead><tr><th>方法</th><th>是否改变原数组</th><th>作用</th></tr></thead><tbody><tr><td><code>push()</code> / <code>pop()</code></td><td>✅</td><td>添加/删除尾部元素</td></tr><tr><td><code>unshift()</code> / <code>shift()</code></td><td>✅</td><td>添加/删除头部元素</td></tr><tr><td><code>splice()</code></td><td>✅</td><td>删除/插入/替换元素</td></tr><tr><td><code>slice()</code></td><td>❌</td><td>截取数组</td></tr><tr><td><code>map()</code></td><td>❌</td><td>遍历并返回新数组</td></tr><tr><td><code>filter()</code></td><td>❌</td><td>过滤元素</td></tr><tr><td><code>reduce()</code></td><td>❌</td><td>累加计算</td></tr><tr><td><code>find()</code> / <code>findIndex()</code></td><td>❌</td><td>查找元素</td></tr><tr><td><code>some()</code> / <code>every()</code></td><td>❌</td><td>检查条件</td></tr><tr><td><code>includes()</code></td><td>❌</td><td>判断是否包含某个值</td></tr><tr><td><code>join()</code></td><td>❌</td><td>数组转字符串</td></tr><tr><td><code>sort()</code></td><td>✅</td><td>排序</td></tr><tr><td><code>reverse()</code></td><td>✅</td><td>反转数组</td></tr><tr><td><code>flat()</code></td><td>❌</td><td>数组扁平化</td></tr></tbody></table><p>这些是面试最常考的数组方法，你还想深入哪些方面？或者要一些练习题？</p><h2 id="slice-和splice-有什么区别" tabindex="-1"><a class="header-anchor" href="#slice-和splice-有什么区别"><span>slice()和splice()有什么区别</span></a></h2><table><thead><tr><th style="text-align:left;"><strong>特性</strong></th><th style="text-align:left;"><strong><code>slice()</code></strong></th><th style="text-align:left;"><strong><code>splice()</code></strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>是否修改原数组</strong></td><td style="text-align:left;">否</td><td style="text-align:left;">是</td></tr><tr><td style="text-align:left;"><strong>功能</strong></td><td style="text-align:left;">截取数组的一部分</td><td style="text-align:left;">删除、替换或添加元素</td></tr><tr><td style="text-align:left;"><strong>参数</strong></td><td style="text-align:left;"><code>(startIndex, endIndex)</code></td><td style="text-align:left;"><code>(startIndex, deleteCount, item1, item2)</code></td></tr><tr><td style="text-align:left;"><strong>返回值</strong></td><td style="text-align:left;">新数组（截取的部分）</td><td style="text-align:left;">被删除元素的数组</td></tr><tr><td style="text-align:left;"><strong>适用场景</strong></td><td style="text-align:left;">复制数组或截取子数组</td><td style="text-align:left;">动态修改数组内容</td></tr></tbody></table><h3 id="call、apply、bind的区别" tabindex="-1"><a class="header-anchor" href="#call、apply、bind的区别"><span>call、apply、bind的区别</span></a></h3><p>都是 JavaScript 中用来<strong>改变函数内部 <code>this</code> 指向</strong>的方法</p><p><code>apply</code> 和 <code>call</code> 基本一样，<strong>唯一的区别是参数以数组的形式传递</strong>。</p><p><code>bind</code> <strong>不会立即执行，而是返回一个新的函数</strong>，该函数的 <code>this</code> 绑定到了指定对象。</p><table><thead><tr><th>方法</th><th>是否立即执行</th><th>参数传递方式</th><th>是否返回新函数</th></tr></thead><tbody><tr><td><code>call</code></td><td>✅ 立即执行</td><td>逗号分隔的参数</td><td>❌</td></tr><tr><td><code>apply</code></td><td>✅ 立即执行</td><td>参数用数组传递</td><td>❌</td></tr><tr><td><code>bind</code></td><td>❌ 不立即执行</td><td>逗号分隔的参数</td><td>✅ 返回新函数</td></tr></tbody></table><h3 id="this指向" tabindex="-1"><a class="header-anchor" href="#this指向"><span>this指向</span></a></h3><table><thead><tr><th>场景</th><th><code>this</code> 指向</th></tr></thead><tbody><tr><td><strong>全局作用域</strong></td><td><code>window</code> / <code>globalThis</code>浏览器中是 <code>window</code>，Node.js 中是 <code>globalThis</code></td></tr><tr><td><strong>对象方法调用</strong></td><td>该对象</td></tr><tr><td><strong>构造函数</strong></td><td>新创建的实例</td></tr><tr><td><strong><code>call</code> / <code>apply</code> / <code>bind</code></strong></td><td>显式指定的对象</td></tr><tr><td><strong>箭头函数</strong></td><td>继承外层作用域的 <code>this</code></td></tr><tr><td><strong><code>setTimeout</code> / <code>setInterval</code></strong></td><td>默认 <code>window</code>（使用箭头函数可继承 <code>this</code>）</td></tr><tr><td><strong>事件监听器</strong></td><td>绑定事件的元素</td></tr><tr><td><strong>class 方法</strong></td><td>实例对象（但可能丢失，需要 <code>bind</code> 或箭头函数）</td></tr></tbody></table><h3 id="new操作符的执行过程" tabindex="-1"><a class="header-anchor" href="#new操作符的执行过程"><span><strong>new操作符的执行过程</strong></span></a></h3><p>（1）首先创建了一个新的空对象</p><p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p><p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p><p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象</p><h3 id="promise" tabindex="-1"><a class="header-anchor" href="#promise"><span>promise</span></a></h3><p><code>promise</code>对象仅有三种状态</p><ul><li><p><code>pending</code>（进行中）</p></li><li><p><code>fulfilled</code>（已成功）</p></li><li><p><code>rejected</code>（已失败）</p></li><li><p>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</p></li><li><p>一旦状态改变（从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>），就不会再变，任何时候都可以得到这个结果</p></li></ul><h3 id="undefined-和-null-的区别" tabindex="-1"><a class="header-anchor" href="#undefined-和-null-的区别"><span><strong><code>undefined</code> 和 <code>null</code> 的区别</strong></span></a></h3><p>在 JavaScript 中，<code>undefined</code> 和 <code>null</code> 都表示“无值”或“空值”，但它们<strong>有本质区别</strong>：</p><table><thead><tr><th>比较项</th><th><code>undefined</code></th><th><code>null</code></th></tr></thead><tbody><tr><td><strong>含义</strong></td><td>变量已声明但未赋值，或函数无返回值</td><td>变量被<strong>手动</strong>赋值为空</td></tr><tr><td><strong>数据类型</strong></td><td><code>undefined</code></td><td><code>object</code>（历史遗留问题）</td></tr><tr><td><strong>全等（===）</strong></td><td><code>undefined !== null</code></td><td><code>null !== undefined</code></td></tr><tr><td><strong>值相等（==）</strong></td><td><code>undefined == null // true</code></td><td><code>null == undefined // true</code></td></tr><tr><td><strong>通常使用场景</strong></td><td>未赋值变量、函数无返回值、对象缺少属性</td><td>代表“空值”或“无对象”</td></tr></tbody></table><h1 id="vue" tabindex="-1"><a class="header-anchor" href="#vue"><span>vue</span></a></h1><h1 id="工程化" tabindex="-1"><a class="header-anchor" href="#工程化"><span>工程化</span></a></h1><table><thead><tr><th style="text-align:left;"><strong>特性</strong></th><th style="text-align:left;"><strong>Webpack</strong></th><th style="text-align:left;"><strong>Vite</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>构建方式</strong></td><td style="text-align:left;">基于打包（Bundle），将所有资源打包成一个或多个文件。</td><td style="text-align:left;">基于原生 ES 模块（ESM），利用浏览器原生支持模块加载，按需加载资源。</td></tr><tr><td style="text-align:left;"><strong>开发模式</strong></td><td style="text-align:left;">开发时需要打包整个应用，启动和热更新较慢。</td><td style="text-align:left;">开发时无需打包，利用浏览器原生 ESM 支持，启动和热更新极快。</td></tr><tr><td style="text-align:left;"><strong>生产模式</strong></td><td style="text-align:left;">打包优化（如 Tree Shaking、代码分割）成熟，适合复杂项目。</td><td style="text-align:left;">使用 Rollup 进行生产打包，性能优秀，但生态和插件支持相对较少。</td></tr></tbody></table><table><thead><tr><th><strong>启动速度</strong></th><th>较慢，需要打包整个应用。</th><th>极快，利用浏览器原生 ESM 按需加载。</th></tr></thead><tbody><tr><td><strong>热更新（HMR）</strong></td><td>较慢，需要重新打包修改的模块。</td><td>极快，仅更新修改的模块，无需重新打包。</td></tr><tr><td><strong>生产构建速度</strong></td><td>较慢，但优化成熟。</td><td>较快，使用 Rollup 打包，但生态和插件支持较少。</td></tr></tbody></table><h3 id="loader和plugin的区别" tabindex="-1"><a class="header-anchor" href="#loader和plugin的区别"><span>loader和plugin的区别</span></a></h3><table><thead><tr><th><strong>对比项</strong></th><th><strong>Loader（加载器）</strong></th><th><strong>Plugin（插件）</strong></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td><strong>转换文件</strong>（如 TypeScript、Sass、图片等）</td><td><strong>扩展 Webpack 功能</strong>（如优化、注入变量、打包）</td></tr><tr><td><strong>执行时机</strong></td><td><strong>模块解析阶段</strong>（文件处理）</td><td><strong>Webpack 生命周期的不同阶段</strong></td></tr><tr><td><strong>配置方式</strong></td><td><code>module.rules</code></td><td><code>plugins</code></td></tr><tr><td><strong>是否是函数</strong></td><td>是函数（输入 → 处理 → 输出）</td><td>是类（通过 <code>apply(compiler)</code> 挂载）</td></tr><tr><td><strong>示例</strong></td><td><code>babel-loader</code>、<code>css-loader</code>、<code>file-loader</code></td><td><code>HtmlWebpackPlugin</code>、<code>MiniCssExtractPlugin</code>、<code>DefinePlugin</code></td></tr></tbody></table><p><strong><code>loader</code> 主要用于</strong>：</p><ul><li><strong>将不同类型的文件转换成 Webpack 能识别的 JavaScript 模块</strong></li><li><strong>单纯的文件转换</strong>，不对 Webpack 运行流程产生影响</li></ul><p><strong><code>plugin</code> 主要用于</strong>：</p><ul><li><strong>扩展 Webpack 的能力</strong>（打包优化、代码压缩、环境变量注入等）</li><li><strong>影响 Webpack 的整个构建流程</strong></li></ul><h1 id="安全性" tabindex="-1"><a class="header-anchor" href="#安全性"><span>安全性</span></a></h1><p>web常见的攻击方式有哪些？如何防御？</p><table><thead><tr><th>攻击方式</th><th>防御措施</th></tr></thead><tbody><tr><td>SQL 注入</td><td>使用预处理语句、输入验证、最小化数据库权限</td></tr><tr><td>XSS</td><td>输出编码、CSP、输入验证</td></tr><tr><td>CSRF</td><td>使用 CSRF Token、验证 Referer 头、SameSite Cookie</td></tr><tr><td>文件上传漏洞</td><td>文件类型检查、文件大小限制、随机文件名</td></tr><tr><td>目录遍历</td><td>输入验证、文件访问权限控制、使用绝对路径</td></tr><tr><td>会话劫持</td><td>使用 HTTPS、HTTPOnly 和 Secure Cookie、定期更新会话 ID</td></tr><tr><td>点击劫持</td><td>X-Frame-Options、Content-Security-Policy</td></tr><tr><td>DDoS 攻击</td><td>使用 CDN 和负载均衡、限制请求速率</td></tr><tr><td>远程代码执行</td><td>代码审计、禁用危险函数、最小化权限</td></tr><tr><td>密码暴力破解</td><td>账户锁定机制、强密码策略、启用 CAPTCHA</td></tr></tbody></table></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><div class="vp-meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: 3024131925@qq.com">白熊想吃鱼</span><!----><!--]--><!--]--></span></div></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-BSV0vqsL.js" defer></script>
  </body>
</html>
