import{_ as d,c as e,d as o,o as r}from"./app-BWpnRMHJ.js";const n={};function l(c,t){return r(),e("div",null,t[0]||(t[0]=[o('<h1 id="css" tabindex="-1"><a class="header-anchor" href="#css"><span>css</span></a></h1><h3 id="_1-选择器的优先级规则" tabindex="-1"><a class="header-anchor" href="#_1-选择器的优先级规则"><span>1.选择器的优先级规则</span></a></h3><p>内联样式 &gt; ID 选择器 &gt; 类、伪类和属性选择器 &gt; 元素和伪元素选择器</p><h3 id="_2-说说em-px-rem-vh-vw区别" tabindex="-1"><a class="header-anchor" href="#_2-说说em-px-rem-vh-vw区别"><span>2.说说em/px/rem/vh/vw区别</span></a></h3><p>px表示像素</p><p>em是相对长度单位。相对于当前对象内文本的字体尺寸。</p><p>rem，相对单位，相对的只是HTML根元素<code>font-size</code>的值</p><p>vh、vw</p><p>vw ，就是根据窗口的宽度，分成100等份，100vw就表示满宽，50vw就表示一半宽。（vw 始终是针对窗口的宽），同理，<code>vh</code>则为窗口的高度</p><h1 id="js" tabindex="-1"><a class="header-anchor" href="#js"><span>js</span></a></h1><h3 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h3><table><thead><tr><th>分类</th><th>类型</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td><strong>原始类型（值类型）</strong></td><td><code>number</code></td><td>数字（整数 &amp; 小数）</td><td><code>42, 3.14, NaN, Infinity</code></td></tr><tr><td></td><td><code>string</code></td><td>字符串</td><td><code>&quot;hello&quot;, &#39;world&#39;</code></td></tr><tr><td></td><td><code>boolean</code></td><td>布尔值</td><td><code>true, false</code></td></tr><tr><td></td><td><code>null</code></td><td>空值，表示<strong>对象为空</strong></td><td><code>let a = null;</code></td></tr><tr><td></td><td><code>undefined</code></td><td>变量未赋值</td><td><code>let b;</code></td></tr><tr><td></td><td><code>symbol</code></td><td>唯一值</td><td><code>Symbol(&quot;id&quot;)</code></td></tr><tr><td></td><td><code>bigint</code></td><td>大整数（ES11）</td><td><code>123n, 9007199254740991n</code></td></tr><tr><td><strong>引用类型（对象类型）</strong></td><td><code>Object</code></td><td>普通对象</td><td><code>{ key: &quot;value&quot; }</code></td></tr><tr><td></td><td><code>Array</code></td><td>数组</td><td><code>[1, 2, 3]</code></td></tr><tr><td></td><td><code>Function</code></td><td>函数</td><td><code>function() {}</code></td></tr><tr><td></td><td><code>Date</code></td><td>日期对象</td><td><code>new Date()</code></td></tr><tr><td></td><td><code>RegExp</code></td><td>正则表达式</td><td><code>/abc/i</code></td></tr><tr><td></td><td><code>Error</code></td><td>错误对象</td><td><code>new Error(&quot;Something went wrong&quot;)</code></td></tr></tbody></table><h3 id="数据类型的检查方法" tabindex="-1"><a class="header-anchor" href="#数据类型的检查方法"><span>数据类型的检查方法</span></a></h3><table><thead><tr><th>方法</th><th>适用场景</th><th>备注</th></tr></thead><tbody><tr><td><code>typeof</code></td><td>适用于基本类型</td><td><code>null</code> 误判为 <code>&quot;object&quot;</code></td></tr><tr><td><code>instanceof</code></td><td>适用于对象类型（数组、日期等）</td><td>不能判断基本类型</td></tr><tr><td><code>Object.prototype.toString.call(value)</code></td><td><strong>最准确</strong></td><td><strong>推荐</strong></td></tr><tr><td><code>Array.isArray(value)</code></td><td>判断数组</td><td><strong>比 <code>instanceof Array</code> 更安全</strong></td></tr><tr><td><code>Number.isNaN(value)</code></td><td>判断 NaN</td><td><strong>比 <code>isNaN()</code> 更精准</strong></td></tr></tbody></table><h3 id="数组的常用方法有哪些" tabindex="-1"><a class="header-anchor" href="#数组的常用方法有哪些"><span>数组的常用方法有哪些</span></a></h3><table><thead><tr><th>方法</th><th>是否改变原数组</th><th>作用</th></tr></thead><tbody><tr><td><code>push()</code> / <code>pop()</code></td><td>✅</td><td>添加/删除尾部元素</td></tr><tr><td><code>unshift()</code> / <code>shift()</code></td><td>✅</td><td>添加/删除头部元素</td></tr><tr><td><code>splice()</code></td><td>✅</td><td>删除/插入/替换元素</td></tr><tr><td><code>slice()</code></td><td>❌</td><td>截取数组</td></tr><tr><td><code>map()</code></td><td>❌</td><td>遍历并返回新数组</td></tr><tr><td><code>filter()</code></td><td>❌</td><td>过滤元素</td></tr><tr><td><code>reduce()</code></td><td>❌</td><td>累加计算</td></tr><tr><td><code>find()</code> / <code>findIndex()</code></td><td>❌</td><td>查找元素</td></tr><tr><td><code>some()</code> / <code>every()</code></td><td>❌</td><td>检查条件</td></tr><tr><td><code>includes()</code></td><td>❌</td><td>判断是否包含某个值</td></tr><tr><td><code>join()</code></td><td>❌</td><td>数组转字符串</td></tr><tr><td><code>sort()</code></td><td>✅</td><td>排序</td></tr><tr><td><code>reverse()</code></td><td>✅</td><td>反转数组</td></tr><tr><td><code>flat()</code></td><td>❌</td><td>数组扁平化</td></tr></tbody></table><p>这些是面试最常考的数组方法，你还想深入哪些方面？或者要一些练习题？</p><h2 id="slice-和splice-有什么区别" tabindex="-1"><a class="header-anchor" href="#slice-和splice-有什么区别"><span>slice()和splice()有什么区别</span></a></h2><table><thead><tr><th style="text-align:left;"><strong>特性</strong></th><th style="text-align:left;"><strong><code>slice()</code></strong></th><th style="text-align:left;"><strong><code>splice()</code></strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>是否修改原数组</strong></td><td style="text-align:left;">否</td><td style="text-align:left;">是</td></tr><tr><td style="text-align:left;"><strong>功能</strong></td><td style="text-align:left;">截取数组的一部分</td><td style="text-align:left;">删除、替换或添加元素</td></tr><tr><td style="text-align:left;"><strong>参数</strong></td><td style="text-align:left;"><code>(startIndex, endIndex)</code></td><td style="text-align:left;"><code>(startIndex, deleteCount, item1, item2)</code></td></tr><tr><td style="text-align:left;"><strong>返回值</strong></td><td style="text-align:left;">新数组（截取的部分）</td><td style="text-align:left;">被删除元素的数组</td></tr><tr><td style="text-align:left;"><strong>适用场景</strong></td><td style="text-align:left;">复制数组或截取子数组</td><td style="text-align:left;">动态修改数组内容</td></tr></tbody></table><h3 id="call、apply、bind的区别" tabindex="-1"><a class="header-anchor" href="#call、apply、bind的区别"><span>call、apply、bind的区别</span></a></h3><p>都是 JavaScript 中用来<strong>改变函数内部 <code>this</code> 指向</strong>的方法</p><p><code>apply</code> 和 <code>call</code> 基本一样，<strong>唯一的区别是参数以数组的形式传递</strong>。</p><p><code>bind</code> <strong>不会立即执行，而是返回一个新的函数</strong>，该函数的 <code>this</code> 绑定到了指定对象。</p><table><thead><tr><th>方法</th><th>是否立即执行</th><th>参数传递方式</th><th>是否返回新函数</th></tr></thead><tbody><tr><td><code>call</code></td><td>✅ 立即执行</td><td>逗号分隔的参数</td><td>❌</td></tr><tr><td><code>apply</code></td><td>✅ 立即执行</td><td>参数用数组传递</td><td>❌</td></tr><tr><td><code>bind</code></td><td>❌ 不立即执行</td><td>逗号分隔的参数</td><td>✅ 返回新函数</td></tr></tbody></table><h3 id="this指向" tabindex="-1"><a class="header-anchor" href="#this指向"><span>this指向</span></a></h3><table><thead><tr><th>场景</th><th><code>this</code> 指向</th></tr></thead><tbody><tr><td><strong>全局作用域</strong></td><td><code>window</code> / <code>globalThis</code>浏览器中是 <code>window</code>，Node.js 中是 <code>globalThis</code></td></tr><tr><td><strong>对象方法调用</strong></td><td>该对象</td></tr><tr><td><strong>构造函数</strong></td><td>新创建的实例</td></tr><tr><td><strong><code>call</code> / <code>apply</code> / <code>bind</code></strong></td><td>显式指定的对象</td></tr><tr><td><strong>箭头函数</strong></td><td>继承外层作用域的 <code>this</code></td></tr><tr><td><strong><code>setTimeout</code> / <code>setInterval</code></strong></td><td>默认 <code>window</code>（使用箭头函数可继承 <code>this</code>）</td></tr><tr><td><strong>事件监听器</strong></td><td>绑定事件的元素</td></tr><tr><td><strong>class 方法</strong></td><td>实例对象（但可能丢失，需要 <code>bind</code> 或箭头函数）</td></tr></tbody></table><h3 id="new操作符的执行过程" tabindex="-1"><a class="header-anchor" href="#new操作符的执行过程"><span><strong>new操作符的执行过程</strong></span></a></h3><p>（1）首先创建了一个新的空对象</p><p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p><p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p><p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象</p><h3 id="promise" tabindex="-1"><a class="header-anchor" href="#promise"><span>promise</span></a></h3><p><code>promise</code>对象仅有三种状态</p><ul><li><p><code>pending</code>（进行中）</p></li><li><p><code>fulfilled</code>（已成功）</p></li><li><p><code>rejected</code>（已失败）</p></li><li><p>对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态</p></li><li><p>一旦状态改变（从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>），就不会再变，任何时候都可以得到这个结果</p></li></ul><h3 id="undefined-和-null-的区别" tabindex="-1"><a class="header-anchor" href="#undefined-和-null-的区别"><span><strong><code>undefined</code> 和 <code>null</code> 的区别</strong></span></a></h3><p>在 JavaScript 中，<code>undefined</code> 和 <code>null</code> 都表示“无值”或“空值”，但它们<strong>有本质区别</strong>：</p><table><thead><tr><th>比较项</th><th><code>undefined</code></th><th><code>null</code></th></tr></thead><tbody><tr><td><strong>含义</strong></td><td>变量已声明但未赋值，或函数无返回值</td><td>变量被<strong>手动</strong>赋值为空</td></tr><tr><td><strong>数据类型</strong></td><td><code>undefined</code></td><td><code>object</code>（历史遗留问题）</td></tr><tr><td><strong>全等（===）</strong></td><td><code>undefined !== null</code></td><td><code>null !== undefined</code></td></tr><tr><td><strong>值相等（==）</strong></td><td><code>undefined == null // true</code></td><td><code>null == undefined // true</code></td></tr><tr><td><strong>通常使用场景</strong></td><td>未赋值变量、函数无返回值、对象缺少属性</td><td>代表“空值”或“无对象”</td></tr></tbody></table><h1 id="vue" tabindex="-1"><a class="header-anchor" href="#vue"><span>vue</span></a></h1><h1 id="工程化" tabindex="-1"><a class="header-anchor" href="#工程化"><span>工程化</span></a></h1><table><thead><tr><th style="text-align:left;"><strong>特性</strong></th><th style="text-align:left;"><strong>Webpack</strong></th><th style="text-align:left;"><strong>Vite</strong></th></tr></thead><tbody><tr><td style="text-align:left;"><strong>构建方式</strong></td><td style="text-align:left;">基于打包（Bundle），将所有资源打包成一个或多个文件。</td><td style="text-align:left;">基于原生 ES 模块（ESM），利用浏览器原生支持模块加载，按需加载资源。</td></tr><tr><td style="text-align:left;"><strong>开发模式</strong></td><td style="text-align:left;">开发时需要打包整个应用，启动和热更新较慢。</td><td style="text-align:left;">开发时无需打包，利用浏览器原生 ESM 支持，启动和热更新极快。</td></tr><tr><td style="text-align:left;"><strong>生产模式</strong></td><td style="text-align:left;">打包优化（如 Tree Shaking、代码分割）成熟，适合复杂项目。</td><td style="text-align:left;">使用 Rollup 进行生产打包，性能优秀，但生态和插件支持相对较少。</td></tr></tbody></table><table><thead><tr><th><strong>启动速度</strong></th><th>较慢，需要打包整个应用。</th><th>极快，利用浏览器原生 ESM 按需加载。</th></tr></thead><tbody><tr><td><strong>热更新（HMR）</strong></td><td>较慢，需要重新打包修改的模块。</td><td>极快，仅更新修改的模块，无需重新打包。</td></tr><tr><td><strong>生产构建速度</strong></td><td>较慢，但优化成熟。</td><td>较快，使用 Rollup 打包，但生态和插件支持较少。</td></tr></tbody></table><h3 id="loader和plugin的区别" tabindex="-1"><a class="header-anchor" href="#loader和plugin的区别"><span>loader和plugin的区别</span></a></h3><table><thead><tr><th><strong>对比项</strong></th><th><strong>Loader（加载器）</strong></th><th><strong>Plugin（插件）</strong></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td><strong>转换文件</strong>（如 TypeScript、Sass、图片等）</td><td><strong>扩展 Webpack 功能</strong>（如优化、注入变量、打包）</td></tr><tr><td><strong>执行时机</strong></td><td><strong>模块解析阶段</strong>（文件处理）</td><td><strong>Webpack 生命周期的不同阶段</strong></td></tr><tr><td><strong>配置方式</strong></td><td><code>module.rules</code></td><td><code>plugins</code></td></tr><tr><td><strong>是否是函数</strong></td><td>是函数（输入 → 处理 → 输出）</td><td>是类（通过 <code>apply(compiler)</code> 挂载）</td></tr><tr><td><strong>示例</strong></td><td><code>babel-loader</code>、<code>css-loader</code>、<code>file-loader</code></td><td><code>HtmlWebpackPlugin</code>、<code>MiniCssExtractPlugin</code>、<code>DefinePlugin</code></td></tr></tbody></table><p><strong><code>loader</code> 主要用于</strong>：</p><ul><li><strong>将不同类型的文件转换成 Webpack 能识别的 JavaScript 模块</strong></li><li><strong>单纯的文件转换</strong>，不对 Webpack 运行流程产生影响</li></ul><p><strong><code>plugin</code> 主要用于</strong>：</p><ul><li><strong>扩展 Webpack 的能力</strong>（打包优化、代码压缩、环境变量注入等）</li><li><strong>影响 Webpack 的整个构建流程</strong></li></ul><h1 id="安全性" tabindex="-1"><a class="header-anchor" href="#安全性"><span>安全性</span></a></h1><p>web常见的攻击方式有哪些？如何防御？</p><table><thead><tr><th>攻击方式</th><th>防御措施</th></tr></thead><tbody><tr><td>SQL 注入</td><td>使用预处理语句、输入验证、最小化数据库权限</td></tr><tr><td>XSS</td><td>输出编码、CSP、输入验证</td></tr><tr><td>CSRF</td><td>使用 CSRF Token、验证 Referer 头、SameSite Cookie</td></tr><tr><td>文件上传漏洞</td><td>文件类型检查、文件大小限制、随机文件名</td></tr><tr><td>目录遍历</td><td>输入验证、文件访问权限控制、使用绝对路径</td></tr><tr><td>会话劫持</td><td>使用 HTTPS、HTTPOnly 和 Secure Cookie、定期更新会话 ID</td></tr><tr><td>点击劫持</td><td>X-Frame-Options、Content-Security-Policy</td></tr><tr><td>DDoS 攻击</td><td>使用 CDN 和负载均衡、限制请求速率</td></tr><tr><td>远程代码执行</td><td>代码审计、禁用危险函数、最小化权限</td></tr><tr><td>密码暴力破解</td><td>账户锁定机制、强密码策略、启用 CAPTCHA</td></tr></tbody></table>',50)]))}const a=d(n,[["render",l],["__file","mian.html.vue"]]),i=JSON.parse('{"path":"/mian.html","title":"css","lang":"zh-CN","frontmatter":{},"headers":[{"level":3,"title":"1.选择器的优先级规则","slug":"_1-选择器的优先级规则","link":"#_1-选择器的优先级规则","children":[]},{"level":3,"title":"2.说说em/px/rem/vh/vw区别","slug":"_2-说说em-px-rem-vh-vw区别","link":"#_2-说说em-px-rem-vh-vw区别","children":[]},{"level":3,"title":"数据类型","slug":"数据类型","link":"#数据类型","children":[]},{"level":3,"title":"数据类型的检查方法","slug":"数据类型的检查方法","link":"#数据类型的检查方法","children":[]},{"level":3,"title":"数组的常用方法有哪些","slug":"数组的常用方法有哪些","link":"#数组的常用方法有哪些","children":[]},{"level":2,"title":"slice()和splice()有什么区别","slug":"slice-和splice-有什么区别","link":"#slice-和splice-有什么区别","children":[{"level":3,"title":"call、apply、bind的区别","slug":"call、apply、bind的区别","link":"#call、apply、bind的区别","children":[]},{"level":3,"title":"this指向","slug":"this指向","link":"#this指向","children":[]},{"level":3,"title":"new操作符的执行过程","slug":"new操作符的执行过程","link":"#new操作符的执行过程","children":[]},{"level":3,"title":"promise","slug":"promise","link":"#promise","children":[]},{"level":3,"title":"undefined 和 null 的区别","slug":"undefined-和-null-的区别","link":"#undefined-和-null-的区别","children":[]},{"level":3,"title":"loader和plugin的区别","slug":"loader和plugin的区别","link":"#loader和plugin的区别","children":[]}]}],"git":{"updatedTime":1742714465000,"contributors":[{"name":"白熊想吃鱼","username":"","email":"3024131925@qq.com","commits":1}],"changelog":[{"hash":"014e28cec3af70a67cf09bf63b2fadc411cd6c0c","time":1742714465000,"email":"3024131925@qq.com","author":"白熊想吃鱼","message":"feat: 添加搜索插件并更新文档配置"}]},"filePathRelative":"mian.md","excerpt":"\\n<h3>1.选择器的优先级规则</h3>\\n<p>内联样式 &gt; ID 选择器 &gt; 类、伪类和属性选择器 &gt; 元素和伪元素选择器</p>\\n<h3>2.说说em/px/rem/vh/vw区别</h3>\\n<p>px表示像素</p>\\n<p>em是相对长度单位。相对于当前对象内文本的字体尺寸。</p>\\n<p>rem，相对单位，相对的只是HTML根元素<code>font-size</code>的值</p>\\n<p>vh、vw</p>\\n<p>vw ，就是根据窗口的宽度，分成100等份，100vw就表示满宽，50vw就表示一半宽。（vw 始终是针对窗口的宽），同理，<code>vh</code>则为窗口的高度</p>"}');export{a as comp,i as data};
