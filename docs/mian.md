# css

### 1.选择器的优先级规则 

内联样式 > ID 选择器 > 类、伪类和属性选择器 > 元素和伪元素选择器



### 2.说说em/px/rem/vh/vw区别

px表示像素

em是相对长度单位。相对于当前对象内文本的字体尺寸。

rem，相对单位，相对的只是HTML根元素`font-size`的值

vh、vw

vw ，就是根据窗口的宽度，分成100等份，100vw就表示满宽，50vw就表示一半宽。（vw 始终是针对窗口的宽），同理，`vh`则为窗口的高度





# js

### 数据类型

| 分类                     | 类型        | 描述                   | 示例                                |
| ------------------------ | ----------- | ---------------------- | ----------------------------------- |
| **原始类型（值类型）**   | `number`    | 数字（整数 & 小数）    | `42, 3.14, NaN, Infinity`           |
|                          | `string`    | 字符串                 | `"hello", 'world'`                  |
|                          | `boolean`   | 布尔值                 | `true, false`                       |
|                          | `null`      | 空值，表示**对象为空** | `let a = null;`                     |
|                          | `undefined` | 变量未赋值             | `let b;`                            |
|                          | `symbol`    | 唯一值                 | `Symbol("id")`                      |
|                          | `bigint`    | 大整数（ES11）         | `123n, 9007199254740991n`           |
| **引用类型（对象类型）** | `Object`    | 普通对象               | `{ key: "value" }`                  |
|                          | `Array`     | 数组                   | `[1, 2, 3]`                         |
|                          | `Function`  | 函数                   | `function() {}`                     |
|                          | `Date`      | 日期对象               | `new Date()`                        |
|                          | `RegExp`    | 正则表达式             | `/abc/i`                            |
|                          | `Error`     | 错误对象               | `new Error("Something went wrong")` |

### 数据类型的检查方法

| 方法                                    | 适用场景                       | 备注                             |
| --------------------------------------- | ------------------------------ | -------------------------------- |
| `typeof`                                | 适用于基本类型                 | `null` 误判为 `"object"`         |
| `instanceof`                            | 适用于对象类型（数组、日期等） | 不能判断基本类型                 |
| `Object.prototype.toString.call(value)` | **最准确**                     | **推荐**                         |
| `Array.isArray(value)`                  | 判断数组                       | **比 `instanceof Array` 更安全** |
| `Number.isNaN(value)`                   | 判断 NaN                       | **比 `isNaN()` 更精准**          |

### 数组的常用方法有哪些

| 方法                     | 是否改变原数组 | 作用               |
| ------------------------ | -------------- | ------------------ |
| `push()` / `pop()`       | ✅              | 添加/删除尾部元素  |
| `unshift()` / `shift()`  | ✅              | 添加/删除头部元素  |
| `splice()`               | ✅              | 删除/插入/替换元素 |
| `slice()`                | ❌              | 截取数组           |
| `map()`                  | ❌              | 遍历并返回新数组   |
| `filter()`               | ❌              | 过滤元素           |
| `reduce()`               | ❌              | 累加计算           |
| `find()` / `findIndex()` | ❌              | 查找元素           |
| `some()` / `every()`     | ❌              | 检查条件           |
| `includes()`             | ❌              | 判断是否包含某个值 |
| `join()`                 | ❌              | 数组转字符串       |
| `sort()`                 | ✅              | 排序               |
| `reverse()`              | ✅              | 反转数组           |
| `flat()`                 | ❌              | 数组扁平化         |

这些是面试最常考的数组方法，你还想深入哪些方面？或者要一些练习题？

## slice()和splice()有什么区别

| **特性**           | **`slice()`**            | **`splice()`**                            |
| :----------------- | :----------------------- | :---------------------------------------- |
| **是否修改原数组** | 否                       | 是                                        |
| **功能**           | 截取数组的一部分         | 删除、替换或添加元素                      |
| **参数**           | `(startIndex, endIndex)` | `(startIndex, deleteCount, item1, item2)` |
| **返回值**         | 新数组（截取的部分）     | 被删除元素的数组                          |
| **适用场景**       | 复制数组或截取子数组     | 动态修改数组内容                          |

### call、apply、bind的区别

都是 JavaScript 中用来**改变函数内部 `this` 指向**的方法

`apply` 和 `call` 基本一样，**唯一的区别是参数以数组的形式传递**。

`bind` **不会立即执行，而是返回一个新的函数**，该函数的 `this` 绑定到了指定对象。

| 方法    | 是否立即执行 | 参数传递方式   | 是否返回新函数 |
| ------- | ------------ | -------------- | -------------- |
| `call`  | ✅ 立即执行   | 逗号分隔的参数 | ❌              |
| `apply` | ✅ 立即执行   | 参数用数组传递 | ❌              |
| `bind`  | ❌ 不立即执行 | 逗号分隔的参数 | ✅ 返回新函数   |

### this指向



| 场景                             | `this` 指向                                                  |
| -------------------------------- | ------------------------------------------------------------ |
| **全局作用域**                   | `window` / `globalThis`浏览器中是 `window`，Node.js 中是 `globalThis` |
| **对象方法调用**                 | 该对象                                                       |
| **构造函数**                     | 新创建的实例                                                 |
| **`call` / `apply` / `bind`**    | 显式指定的对象                                               |
| **箭头函数**                     | 继承外层作用域的 `this`                                      |
| **`setTimeout` / `setInterval`** | 默认 `window`（使用箭头函数可继承 `this`）                   |
| **事件监听器**                   | 绑定事件的元素                                               |
| **class 方法**                   | 实例对象（但可能丢失，需要 `bind` 或箭头函数）               |

### **new操作符的执行过程**

（1）首先创建了一个新的空对象

（2）设置原型，将对象的原型设置为函数的 prototype 对象。

（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）

（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象

### promise

`promise`对象仅有三种状态

- `pending`（进行中）
- `fulfilled`（已成功）
- `rejected`（已失败）

- 对象的状态不受外界影响，只有异步操作的结果，可以决定当前是哪一种状态
- 一旦状态改变（从`pending`变为`fulfilled`和从`pending`变为`rejected`），就不会再变，任何时候都可以得到这个结果

### **`undefined` 和 `null` 的区别**	

在 JavaScript 中，`undefined` 和 `null` 都表示“无值”或“空值”，但它们**有本质区别**：

| 比较项           | `undefined`                            | `null`                      |
| ---------------- | -------------------------------------- | --------------------------- |
| **含义**         | 变量已声明但未赋值，或函数无返回值     | 变量被**手动**赋值为空      |
| **数据类型**     | `undefined`                            | `object`（历史遗留问题）    |
| **全等（===）**  | `undefined !== null`                   | `null !== undefined`        |
| **值相等（==）** | `undefined == null // true`            | `null == undefined // true` |
| **通常使用场景** | 未赋值变量、函数无返回值、对象缺少属性 | 代表“空值”或“无对象”        |

# vue

# 工程化

| **特性**     | **Webpack**                                               | **Vite**                                                     |
| :----------- | :-------------------------------------------------------- | :----------------------------------------------------------- |
| **构建方式** | 基于打包（Bundle），将所有资源打包成一个或多个文件。      | 基于原生 ES 模块（ESM），利用浏览器原生支持模块加载，按需加载资源。 |
| **开发模式** | 开发时需要打包整个应用，启动和热更新较慢。                | 开发时无需打包，利用浏览器原生 ESM 支持，启动和热更新极快。  |
| **生产模式** | 打包优化（如 Tree Shaking、代码分割）成熟，适合复杂项目。 | 使用 Rollup 进行生产打包，性能优秀，但生态和插件支持相对较少。 |

| **启动速度**      | 较慢，需要打包整个应用。       | 极快，利用浏览器原生 ESM 按需加载。            |
| ----------------- | ------------------------------ | ---------------------------------------------- |
| **热更新（HMR）** | 较慢，需要重新打包修改的模块。 | 极快，仅更新修改的模块，无需重新打包。         |
| **生产构建速度**  | 较慢，但优化成熟。             | 较快，使用 Rollup 打包，但生态和插件支持较少。 |

### loader和plugin的区别

| **对比项**     | **Loader（加载器）**                        | **Plugin（插件）**                                          |
| -------------- | ------------------------------------------- | ----------------------------------------------------------- |
| **作用**       | **转换文件**（如 TypeScript、Sass、图片等） | **扩展 Webpack 功能**（如优化、注入变量、打包）             |
| **执行时机**   | **模块解析阶段**（文件处理）                | **Webpack 生命周期的不同阶段**                              |
| **配置方式**   | `module.rules`                              | `plugins`                                                   |
| **是否是函数** | 是函数（输入 → 处理 → 输出）                | 是类（通过 `apply(compiler)` 挂载）                         |
| **示例**       | `babel-loader`、`css-loader`、`file-loader` | `HtmlWebpackPlugin`、`MiniCssExtractPlugin`、`DefinePlugin` |

**`loader` 主要用于**：

- **将不同类型的文件转换成 Webpack 能识别的 JavaScript 模块**
- **单纯的文件转换**，不对 Webpack 运行流程产生影响

**`plugin` 主要用于**：

- **扩展 Webpack 的能力**（打包优化、代码压缩、环境变量注入等）
- **影响 Webpack 的整个构建流程**



# 安全性

web常见的攻击方式有哪些？如何防御？

| 攻击方式     | 防御措施                                               |
| ------------ | ------------------------------------------------------ |
| SQL 注入     | 使用预处理语句、输入验证、最小化数据库权限             |
| XSS          | 输出编码、CSP、输入验证                                |
| CSRF         | 使用 CSRF Token、验证 Referer 头、SameSite Cookie      |
| 文件上传漏洞 | 文件类型检查、文件大小限制、随机文件名                 |
| 目录遍历     | 输入验证、文件访问权限控制、使用绝对路径               |
| 会话劫持     | 使用 HTTPS、HTTPOnly 和 Secure Cookie、定期更新会话 ID |
| 点击劫持     | X-Frame-Options、Content-Security-Policy               |
| DDoS 攻击    | 使用 CDN 和负载均衡、限制请求速率                      |
| 远程代码执行 | 代码审计、禁用危险函数、最小化权限                     |
| 密码暴力破解 | 账户锁定机制、强密码策略、启用 CAPTCHA                 |